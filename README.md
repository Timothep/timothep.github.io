# Developer's Journey

## Foreword

What is a good software developer? There are as many definitions as IT-professionals on this planet. Heck we can‘t even agree on what we should be called. Is it Software-engineers, developers, crafters, writers...?

One thing is clear though, there is a set of common traits and practices that unite those good software developers. Testing, Pair-Programming, patterns, focus, Discipline, communication, code readability, naming etc. those traits and practices are like tools on a tool-belt. Some of them are out all the time. Some we carry them around and seldom take out of their slots. Newcomer in our industry, face the herculean task to learn what all those tools are, and when (not) to use them. But it would be too easy if you knew which tools there are in the first place. Discovering which one there are is part of the job. Furthermore, new tools are created everyday. Once you found a new tool, you will often discover that we don‘t even agree on how to use them. So we are left with experimenting. We make very small decisions, observe their effects and revise those decisions to make even more (and better) of them.

Being a software developer is all about making decisions. Be it naming objects, picking design patterns or messing up with democracy. We are in charge. We are “The new Kingmakers” wrote Stephen O'Grady. We make decisions for ourselves, our colleagues and for mankind. Sometimes even with a keen ethical sense. Wouldn‘t it be nice if we could rewind those decisions once in a while? Wouldn‘t it be helpful to go down one rabbit hole and see the effects of one decision before trying another one? Wouldn‘t that be the best way to learn how those tools work?

This is the purpose of this gamebook. It neither has the pretense to be complete nor to be fully correct. But it is a study of the most complete toolbelt I could come up with... while remaining entertaining. The goal of this gamebook is to name those tools and briefly present them in a practical context. Once you’ve learned about such a tool, you should be ready to pursue your inquiry on your own. The very nature of this gamebook helps us then go down different rabbit holes and see common short, mid and long term effects those tools have on our developer's journeys.
​
## The principles behind the book

### Non-linearity is a feature

If you have never held a gamebook in your hands, brace yourself. The plot is like a giant tree. At the end of every section (a few paragraphs), you will be asked to make a decision or forced to randomly decide what will happen. Depending on the outcome, you will get the reference of the next section you should go to. Go there, read the next section and let the flow drive you through the story.

### On the use of tokens

Once in a while, you will get or use some tokens. For instance the [ReadHalfOfTheReadme_Token]. You've just gained it. Write down those tokens when you receive them, and strike them through when you used them. The story will tell you something like "if you have the [ReadHalfOfTheReadme_Token], go to section 42, otherwise go to section 666". Some tokens appear multiple times. Write every token you get and strike down one of them each time you use them. Those tokens help give the gamebook even more depth. Your actions can thus have delayed effects on the story, without impacting the next actions you will do.

### Explore the storyline

Reading this gamebook will not be a linear experience. Go down one path. Learn about a new tool. See what it does. Put down the book and research what it means. The goal of the book is not to be hard and make you fight your way through. It is still to let you explore all the branches and discover about the world. Attached to each chapter is a tree-map of all the decision paths to ease this exploration. I recommend playing each chapter once without having a look at it, and then go back and try alternative paths to see where they lead you. Rewind, go back to one decision and see how picking another answer affects the outcome. So make decisions, experiment, and find all the endings of the game. Or play it through in one go... who am I to tell you how to play anyway?

## A participative journey

The writing process of this gamebook is a participative journey in itself. I created a skeleton of the whole story to make sure that all the elements & tools I intend to speak about have a place in it. But it doesn't mean it will end up where I though it could fit. I already created a high level overview of the branching, but I expect this to evolve overtime as well. Now that this is in place, I intend to start writing the 25 chapters, one after the other, and publish them each time one of them is ready.

This means that are able to see this gamebook being written and take part into its creation. Play through a chapter and then give me feedback. Did you feel limited in the available options at a particular decision point? Open a new issue about that particular line and let me know what you would have preferred and why. You can even make a pull request if you feel like it. Grab this chance in helping me crafting the best gamebook about software development there is (I couldn't find any other anyway ;)

## How to use this gamebook?

There are multiple ways to enjoy this gamebook.

### Interactively

The first one is to enjoy it interactively. This gamebook is created using [Twine](https://twinery.org/). After each chapter is completed, a playable version will be uploaded here. Here are the links to jump right into the action (note that you must have played from the begining to be able to handle the tokens):

 * First Chapter...

Note that you cannot roll back to the middle of a chapter, you have to click through.

### Read it as a book

Each chapter has a single entry point and is compiled as a linear book with various sections. Each section is numbered and referenced throughout the book.

* First Chapter...

## Copyright

All rights reserved Timothée Bourguignon 2018.
